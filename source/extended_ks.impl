#include "unaligned.h"


IMPLEMENT_OVERLOAD(SetPlayerPos, Vector3_16)
(Player& player, const char* params, short minFrame, short maxFrame)
{
	player.pos = ReadUnaligned<Vector3_16>(params);
}


IMPLEMENT_OVERLOAD(MovePlayer, Vector3_16)
(Player& player, const char* params, short minFrame, short maxFrame)
{
	player.pos += ReadUnaligned<Vector3_16>(params);
}


IMPLEMENT(SetPlayerAngleY<>)
(Player& player, const char* params, short minFrame, short maxFrame)
{
	player.ang.y = ReadUnaligned<short>(params);
}


IMPLEMENT(TurnPlayer<>)
(Player& player, const char* params, short minFrame, short maxFrame)
{
	player.ang.y += ReadUnaligned<short>(params);
}


IMPLEMENT(ExpDecayPlayerAngleY<>)
(Player& player, const char* params, short minFrame, short maxFrame)
{
	const auto [targetAngle, invFactor, maxDelta, minDelta]
		= ReadUnaligned<short, int, int, int>(params);

	ApproachAngle(player.ang.y, targetAngle, invFactor, maxDelta, minDelta);
}


IMPLEMENT(HurtPlayer<>)
(Player& player, const char* params, short minFrame, short maxFrame)
{
	const Vector3 source = ReadUnaligned<Vector3_16>(params);

	const auto [damage, speed, arg4, presetHurt, spawnOuchParticles]
		= ReadUnaligned<unsigned, Fix12i, unsigned, unsigned, unsigned>(params + 6);

	player.Hurt(source, damage, speed, arg4, presetHurt, spawnOuchParticles);
}


IMPLEMENT(BurnPlayer<>)
(Player& player, const char* params, short minFrame, short maxFrame)
{
	player.Burn();
}


IMPLEMENT(ShockPlayer<>)
(Player& player, const char* params, short minFrame, short maxFrame)
{
	player.Shock(ReadUnaligned<unsigned>(params));
}


IMPLEMENT(BouncePlayer<>)
(Player& player, const char* params, short minFrame, short maxFrame)
{
	player.Bounce(ReadUnaligned<Fix12i>(params));
}


IMPLEMENT(PlayLong<>)
(Player& player, const char* params, short minFrame, short maxFrame)
{
	const auto [soundArchiveID, soundID] = ReadUnaligned<unsigned, unsigned>(params);

	player.playLongUniqueID = Sound::PlayLong(player.playLongUniqueID, soundArchiveID, soundID, player.camSpacePos, 0);
}


IMPLEMENT(PrintPlayerPos<>)
(Player& player, const char* params, short minFrame, short maxFrame)
{
	cout << player.pos;
}

constinit int8_t entranceMode = -1;

IMPLEMENT(SetEntranceMode)
(Player& player, const char* params, short minFrame, short maxFrame)
{
	entranceMode = *params;
}

asm(R"(
nsub_0200e664:
	ldr   r1, =entranceMode
	ldrb  r1, [r1]
	cmp   r1, #0xff
	movne r12, r1
	mvn   r1, #0
	b     0x0200e668
)");

static Fix12i IterateSmoothStep(Fix12i t, unsigned n)
{
	for (unsigned i = 0; i < n; i++)
		t = SmoothStep(t);

	return t;
}

static void CubicInterpVec(Vector3& res, const char* params, short minFrame, short maxFrame, Vector3& v0)
{
	const Fix12i t = Fix12i(KS_FRAME_COUNTER - minFrame, as_raw) / Fix12i(maxFrame - minFrame, as_raw);
	if(t == 0_f) v0 = res;

	const Vector3 v1 = ReadUnaligned<Vector3_16>(params);
	const unsigned smoothness = params[6];

	AssureUnaliased(res) = Lerp(v0, v1, IterateSmoothStep(t, smoothness));
}


IMPLEMENT_OVERLOAD(LerpCamPos, Vector3_16, uint8_t)
(Camera& cam, const char* params, short minFrame, short maxFrame)
{
	static constinit Vector3 sourcePos;

	CubicInterpVec(cam.pos, params, minFrame, maxFrame, sourcePos);
}


IMPLEMENT_OVERLOAD(LerpCamTarget, Vector3_16, uint8_t)
(Camera& cam, const char* params, short minFrame, short maxFrame)
{
	static constinit Vector3 sourceLookAt;

	CubicInterpVec(cam.lookAt, params, minFrame, maxFrame, sourceLookAt);
}


IMPLEMENT(DisableAmbientSoundEffects)
(Camera& cam, const char* params, short minFrame, short maxFrame)
{
	AMBIENT_SOUND_EFFECTS_ENABLED = 1;
}


IMPLEMENT(PrintCamPos)
(Camera& cam, const char* params, short minFrame, short maxFrame)
{
	cout << cam.pos;
}

IMPLEMENT(PrintCamTarget)
(Camera& cam, const char* params, short minFrame, short maxFrame)
{
	cout << cam.lookAt;
}


IMPLEMENT(PrintFrameCounter)
(Camera& cam, const char* params, short minFrame, short maxFrame)
{
	cout << KS_FRAME_COUNTER;
}


IMPLEMENT(Print<1>)
(Camera& cam, const char* params, short minFrame, short maxFrame)
{
	cout << params;
}
